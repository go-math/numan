package polynomial

import (
	"testing"

	"github.com/ready-steady/adapt/grid/equidistant"
	"github.com/ready-steady/adapt/internal"
	"github.com/ready-steady/assert"
)

func BenchmarkOpenCompute1(b *testing.B) {
	benchmarkOpenCompute(1, b)
}

func benchmarkOpenCompute(power uint, b *testing.B) {
	const (
		nd = 10
		ns = 100000
	)

	basis := NewOpen(nd, power)
	indices := generateIndices(nd, ns, equidistant.NewOpen(nd).Refine)
	points := generatePoints(nd, ns, indices, basis.grid.Node)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		for j := 0; j < ns; j++ {
			basis.Compute(indices[j*nd:(j+1)*nd], points[j*nd:(j+1)*nd])
		}
	}
}

func TestOpenCompute(t *testing.T) {
	basis := NewOpen(1, 1)

	compute := func(level, order uint64, point float64) float64 {
		return basis.Compute(internal.Compose([]uint64{level}, []uint64{order}), []float64{point})
	}

	points := []float64{
		0.00, 0.04, 0.08, 0.12, 0.16, 0.20, 0.24, 0.28, 0.32, 0.36, 0.40, 0.44, 0.48,
		0.52, 0.56, 0.60, 0.64, 0.68, 0.72, 0.76, 0.80, 0.84, 0.88, 0.92, 0.96, 1.00,
	}

	cases := []struct {
		level  uint64
		order  uint64
		values []float64
	}{
		{0, 0, []float64{
			1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00,
			1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00,
		}},
		{1, 0, []float64{
			2.00, 1.84, 1.68, 1.52, 1.36, 1.20, 1.04, 0.88, 0.72, 0.56, 0.40, 0.24, 0.08,
			0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
		}},
		{1, 2, []float64{
			0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
			0.08, 0.24, 0.40, 0.56, 0.72, 0.88, 1.04, 1.20, 1.36, 1.52, 1.68, 1.84, 2.00,
		}},
		{2, 0, []float64{
			2.00, 1.68, 1.36, 1.04, 0.72, 0.40, 0.08, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
			0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
		}},
		{2, 2, []float64{
			0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.24, 0.56, 0.88, 0.80, 0.48, 0.16,
			0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
		}},
		{2, 4, []float64{
			0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
			0.16, 0.48, 0.80, 0.88, 0.56, 0.24, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
		}},
		{2, 6, []float64{
			0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
			0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.08, 0.40, 0.72, 1.04, 1.36, 1.68, 2.00,
		}},
		{3, 0, []float64{
			2.00, 1.36, 0.72, 0.08, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
			0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
		}},
		{3, 2, []float64{
			0.00, 0.00, 0.00, 0.00, 0.56, 0.80, 0.16, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
			0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
		}},
		{3, 4, []float64{
			0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.48, 0.88, 0.24, 0.00, 0.00, 0.00,
			0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
		}},
		{3, 6, []float64{
			0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.40, 0.96, 0.32,
			0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
		}},
		{3, 8, []float64{
			0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
			0.32, 0.96, 0.40, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
		}},
		{3, 10, []float64{
			0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
			0.00, 0.00, 0.00, 0.24, 0.88, 0.48, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
		}},
		{3, 12, []float64{
			0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
			0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.16, 0.80, 0.56, 0.00, 0.00, 0.00, 0.00,
		}},
		{3, 14, []float64{
			0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
			0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.08, 0.72, 1.36, 2.00,
		}},
	}

	values := make([]float64, len(points))

	for i := range cases {
		for j := range values {
			values[j] = compute(cases[i].level, cases[i].order, points[j])
		}
		assert.Close(values, cases[i].values, 1e-15, t)
	}
}

func TestOpenIntegrate(t *testing.T) {
	basis := NewOpen(1, 1)

	levels := []uint64{0, 1, 1, 2, 2, 2, 2}
	orders := []uint64{0, 0, 2, 0, 2, 4, 6}
	values := []float64{1.0, 0.5, 0.5, 0.25, 0.125, 0.125, 0.25}

	for i := range levels {
		indices := internal.Compose([]uint64{levels[i]}, []uint64{orders[i]})
		assert.Equal(basis.Integrate(indices), values[i], t)
	}
}
